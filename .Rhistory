cor(use = "pairwise.complete.obs")
# reshape + relabel
cor_long <- cor_mat %>%
as.data.frame() %>%
rownames_to_column("var1") %>%
pivot_longer(-var1, names_to = "var2", values_to = "correlation") %>%
mutate(
var1 = recode(var1, !!!var_labels),
var2 = recode(var2, !!!var_labels)
)
# heatmap
ggplot(cor_long, aes(var1, var2, fill = correlation)) +
geom_tile(color = "white") +
geom_text(aes(label = sprintf("%.2f", correlation)),
size = 3) +
scale_fill_gradient2(
low = "#4575B4",
mid = "white",
high = "#D73027",
midpoint = 0,
limits = c(-1, 1),
name = "Correlation"
) +
coord_equal() +
labs(
title = "Correlation Heatmap: Environmental & Demographic Variables",
x = NULL,
y = NULL
) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1),
plot.title = element_text(face = "bold", hjust = 0.5)
)
df_model <- df %>%
mutate(cbsa_in_state = interaction(state_fips, cbsa_id, drop = TRUE))
m1 <- lmer(
pm25 ~ pct_white_10 + log_dens + pct_pov + ruca_agg + bc + hyads +
(1 | state_fips) + (1 | cbsa_in_state),
data = df_model,
REML = TRUE
)
m1 <- lmer(
pm25 ~ pct_white + log_dens + pct_pov + ruca_agg + bc + hyads +
(1 | state_fips) + (1 | cbsa_in_state),
data = df_model,
REML = TRUE
)
df_model <- df %>%
mutate(
# IDs
state_fips = str_pad(as.character(state_fips), 2, pad = "0"),
cbsa_id    = as.character(cbsa_id),
# nested cluster ID
cbsa_in_state = interaction(state_fips, cbsa_id, drop = TRUE),
# Urbanicity as factor (set your preferred baseline)
ruca_agg = factor(ruca_agg, levels = c("urban", "suburban", "rural")),
# Key transforms
pct_white_10 = pct_white / 10,         # +10 percentage points
log_dens     = log(dens + 1e-6)         # avoid log(0)
) %>%
# keep complete cases for variables used in models
drop_na(pm25, pct_white_10, log_dens, pct_pov, ruca_agg, bc, hyads, state_fips, cbsa_in_state, cbsa_id)
# -------------------------
# 1) Primary multilevel model
#    Random intercepts: state + CBSA-within-state
# -------------------------
m1 <- lmer(
pm25 ~ pct_white_10 + log_dens + pct_pov + ruca_agg + bc + hyads +
(1 | state_fips) + (1 | cbsa_in_state),
data = df_model,
REML = TRUE
)
summary(m1)
confint(m1, method = "Wald")  # quick CI
# Tidy fixed effects
broom.mixed::tidy(m1, effects = "fixed", conf.int = TRUE)
# Diagnostics
performance::check_model(m1)
# Interpretation helper: effect per +10 percentage points White
beta_white <- fixef(m1)["pct_white_10"]
cat("\nEstimated change in PM2.5 for +10 percentage points White:",
round(beta_white, 4), "ug/m^3\n")
# ------------------------------------------------
# 2) Sensitivity A: random slope for % White by CBSA-in-state
#    (more flexible, can be slower / may warn if near-singular)
# ------------------------------------------------
m2 <- lmer(
pm25 ~ pct_white_10 + log_dens + pct_pov + ruca_agg + bc + hyads +
(1 | state_fips) + (1 + pct_white_10 | cbsa_in_state),
data = df_model,
REML = TRUE,
control = lmerControl(optimizer = "bobyqa")
)
summary(m2)
performance::check_model(m2)
# Compare m1 vs m2 (REML=TRUE isn’t ideal for LRT; refit with REML=FALSE if you want formal LRT)
m1_ml <- update(m1, REML = FALSE)
m2_ml <- update(m2, REML = FALSE)
anova(m1_ml, m2_ml)
# ------------------------------------------------
# 3) Sensitivity B: CBSA + state fixed effects (within-CBSA comparison)
#    with cluster-robust SE by CBSA
# ------------------------------------------------
m_fe <- lm(
pm25 ~ pct_white_10 + log_dens + pct_pov + ruca_agg + bc + hyads +
factor(state_fips) + factor(cbsa_id),
data = df_model
)
summary(m_fe)
# Cluster-robust SE at CBSA level
coeftest(m_fe, vcov = vcovCL(m_fe, cluster = ~ cbsa_id))
df_geo <- tract_sf %>%
left_join(df, by = "geoid") %>%
filter(!is.na(pm25)) %>%
st_transform(5070) %>%                   # planar CRS (meters); good for distances
mutate(cent = st_centroid(geometry)) %>%
mutate(
x = st_coordinates(cent)[,1],
y = st_coordinates(cent)[,2]
) %>%
st_drop_geometry()
df <- readr::read_csv("tract_cbsa.csv", show_col_types = FALSE) %>%
mutate(
state_fips = str_pad(as.character(state_fips), 2, pad = "0"),
cbsa_id    = as.character(cbsa_id),
geoid      = str_pad(as.character(geoid), 11, pad = "0"),
cbsa_in_state = interaction(state_fips, cbsa_id, drop = TRUE),
ruca_agg = factor(ruca_agg, levels = c("urban","suburban","rural")),
pct_white_10 = pct_white / 10,
log_dens = log(dens + 1e-6)
)
# ---- Get 2010 tract geometries for states in your data + join by GEOID
states_needed <- sort(unique(df$state_fips))
tract_sf <- purrr::map_dfr(states_needed, function(st) {
tmp <- tigris::tracts(state = st, year = 2010, cb = TRUE, class = "sf")
# Robustly build 11-digit GEOID
nms <- names(tmp)
geoid_candidates <- nms[grepl("GEOID", nms, ignore.case = TRUE)]
if (length(geoid_candidates) > 0) {
gfull <- as.character(tmp[[geoid_candidates[1]]])
geoid11 <- stringr::str_extract(gfull, "\\d{11}$")
} else {
st_col <- nms[grepl("^STATEFP",  nms, ignore.case = TRUE)][1]
co_col <- nms[grepl("^COUNTYFP", nms, ignore.case = TRUE)][1]
tr_col <- nms[grepl("^TRACTCE",  nms, ignore.case = TRUE)][1]
geoid11 <- paste0(
str_pad(as.character(tmp[[st_col]]), 2, pad = "0"),
str_pad(as.character(tmp[[co_col]]), 3, pad = "0"),
str_pad(as.character(tmp[[tr_col]]), 6, pad = "0")
)
}
tmp %>% mutate(geoid = geoid11) %>% select(geoid, geometry)
})
df_geo <- tract_sf %>%
left_join(df, by = "geoid") %>%
filter(!is.na(pm25)) %>%
st_transform(5070) %>%                   # planar CRS (meters); good for distances
mutate(cent = st_centroid(geometry)) %>%
mutate(
x = st_coordinates(cent)[,1],
y = st_coordinates(cent)[,2]
) %>%
st_drop_geometry()
# Spatial position factor (coordinates in meters; rounding reduces accidental duplicates)
df_fit <- df_fit %>%
mutate(
pos = numFactor(round(x), round(y)),
dummy = factor(1)   # required "grouping" factor for the spatial covariance term
)
# Spatial position factor (coordinates in meters; rounding reduces accidental duplicates)
df_fit <- df_geo%>%
mutate(
pos = numFactor(round(x), round(y)),
dummy = factor(1)   # required "grouping" factor for the spatial covariance term
)
library(tidyverse)
library(sf)
library(tigris)
library(glmmTMB)
library(stringr)
# Spatial position factor (coordinates in meters; rounding reduces accidental duplicates)
df_fit <- df_geo%>%
mutate(
pos = numFactor(round(x), round(y)),
dummy = factor(1)   # required "grouping" factor for the spatial covariance term
)
m_sp_mat <- glmmTMB(
pm25 ~ pct_white_10 + log_dens + pct_pov + ruca_agg + bc + hyads +
(1 | state_fips) + (1 | cbsa_in_state) +
mat(pos + 0 | dummy),
data = df_fit,
family = gaussian()
)
df <- readr::read_csv("tract_cbsa.csv", show_col_types = FALSE) %>%
mutate(
state_fips = str_pad(as.character(state_fips), 2, pad = "0"),
cbsa_id    = as.character(cbsa_id),
geoid      = str_pad(as.character(geoid), 11, pad = "0"),
cbsa_in_state = interaction(state_fips, cbsa_id, drop = TRUE),
ruca_agg = factor(ruca_agg, levels = c("urban","suburban","rural")),
pct_white_10 = pct_white / 10,
log_dens = log(dens + 1e-6)
)
# ---- Get 2010 tract geometries for states in your data + join by GEOID
states_needed <- sort(unique(df$state_fips))
tract_sf <- purrr::map_dfr(states_needed, function(st) {
tmp <- tigris::tracts(state = st, year = 2010, cb = TRUE, class = "sf")
# Robustly build 11-digit GEOID
nms <- names(tmp)
geoid_candidates <- nms[grepl("GEOID", nms, ignore.case = TRUE)]
if (length(geoid_candidates) > 0) {
gfull <- as.character(tmp[[geoid_candidates[1]]])
geoid11 <- stringr::str_extract(gfull, "\\d{11}$")
} else {
st_col <- nms[grepl("^STATEFP",  nms, ignore.case = TRUE)][1]
co_col <- nms[grepl("^COUNTYFP", nms, ignore.case = TRUE)][1]
tr_col <- nms[grepl("^TRACTCE",  nms, ignore.case = TRUE)][1]
geoid11 <- paste0(
str_pad(as.character(tmp[[st_col]]), 2, pad = "0"),
str_pad(as.character(tmp[[co_col]]), 3, pad = "0"),
str_pad(as.character(tmp[[tr_col]]), 6, pad = "0")
)
}
tmp %>% mutate(geoid = geoid11) %>% select(geoid, geometry)
})
df_geo <- tract_sf %>%
left_join(df, by = "geoid") %>%
filter(!is.na(pm25)) %>%
st_transform(5070) %>%                   # planar CRS (meters); good for distances
mutate(cent = st_centroid(geometry)) %>%
mutate(
x = st_coordinates(cent)[,1],
y = st_coordinates(cent)[,2]
) %>%
st_drop_geometry()
# Spatial position factor (coordinates in meters; rounding reduces accidental duplicates)
df_fit <- df_geo%>%
mutate(
pos = numFactor(round(x), round(y)),
dummy = factor(1)   # required "grouping" factor for the spatial covariance term
)
m_sp_mat <- glmmTMB(
pm25 ~ pct_white_10 + log_dens + pct_pov + ruca_agg + bc + hyads +
(1 | state_fips) + (1 | cbsa_in_state) +
mat(pos + 0 | dummy),
data = df_fit,
family = gaussian()
)
df <- readr::read_csv("tract_cbsa.csv", show_col_types = FALSE) %>%
mutate(
state_fips = str_pad(as.character(state_fips), 2, pad = "0"),
cbsa_id    = as.character(cbsa_id),
geoid      = str_pad(as.character(geoid), 11, pad = "0"),
cbsa_in_state = interaction(state_fips, cbsa_id, drop = TRUE),
ruca_agg = factor(ruca_agg, levels = c("urban","suburban","rural")),
pct_white_10 = pct_white / 10,
log_dens = log(dens + 1e-6)
)
# ---- Get 2010 tract geometries for states in your data + join by GEOID
states_needed <- sort(unique(df$state_fips))
tract_sf <- purrr::map_dfr(states_needed, function(st) {
tmp <- tigris::tracts(state = st, year = 2010, cb = TRUE, class = "sf")
# Robustly build 11-digit GEOID
nms <- names(tmp)
geoid_candidates <- nms[grepl("GEO_ID", nms, ignore.case = TRUE)]
if (length(geoid_candidates) > 0) {
gfull <- as.character(tmp[[geoid_candidates[1]]])
geoid11 <- stringr::str_extract(gfull, "\\d{11}$")
} else {
st_col <- nms[grepl("^STATEFP",  nms, ignore.case = TRUE)][1]
co_col <- nms[grepl("^COUNTYFP", nms, ignore.case = TRUE)][1]
tr_col <- nms[grepl("^TRACTCE",  nms, ignore.case = TRUE)][1]
geoid11 <- paste0(
str_pad(as.character(tmp[[st_col]]), 2, pad = "0"),
str_pad(as.character(tmp[[co_col]]), 3, pad = "0"),
str_pad(as.character(tmp[[tr_col]]), 6, pad = "0")
)
}
tmp %>% mutate(geoid = geoid11) %>% select(geoid, geometry)
})
df_geo <- tract_sf %>%
left_join(df, by = "geoid") %>%
filter(!is.na(pm25)) %>%
st_transform(5070) %>%                   # planar CRS (meters); good for distances
mutate(cent = st_centroid(geometry)) %>%
mutate(
x = st_coordinates(cent)[,1],
y = st_coordinates(cent)[,2]
) %>%
st_drop_geometry()
# Spatial position factor (coordinates in meters; rounding reduces accidental duplicates)
df_fit <- df_geo%>%
mutate(
pos = numFactor(round(x), round(y)),
dummy = factor(1)   # required "grouping" factor for the spatial covariance term
)
m_sp_mat <- glmmTMB(
pm25 ~ pct_white_10 + log_dens + pct_pov + ruca_agg + bc + hyads +
(1 | state_fips) + (1 | cbsa_in_state) +
mat(pos + 0 | dummy),
data = df_fit,
family = gaussian()
)
df <- readr::read_csv("tract_cbsa.csv", show_col_types = FALSE) %>%
mutate(
state_fips = str_pad(as.character(state_fips), 2, pad = "0"),
cbsa_id    = as.character(cbsa_id),
geoid      = str_pad(as.character(geoid), 11, pad = "0"),
cbsa_in_state = interaction(state_fips, cbsa_id, drop = TRUE),
ruca_agg = factor(ruca_agg, levels = c("urban","suburban","rural")),
pct_white_10 = pct_white / 10,
log_dens = log(dens + 1e-6)
)
# ---- Get 2010 tract geometries for states in your data + join by GEOID
states_needed <- sort(unique(df$state_fips))
tract_sf <- purrr::map_dfr(states_needed, function(st) {
tmp <- tigris::tracts(state = st, year = 2010, cb = TRUE, class = "sf")
# Robustly build 11-digit GEOID
nms <- names(tmp)
geoid_candidates <- nms[grepl("GEO_ID", nms, ignore.case = TRUE)]
if (length(geoid_candidates) > 0) {
gfull <- as.character(tmp[[geoid_candidates[1]]])
geoid11 <- stringr::str_extract(gfull, "\\d{11}$")
} else {
st_col <- nms[grepl("^STATEFP",  nms, ignore.case = TRUE)][1]
co_col <- nms[grepl("^COUNTYFP", nms, ignore.case = TRUE)][1]
tr_col <- nms[grepl("^TRACTCE",  nms, ignore.case = TRUE)][1]
geoid11 <- paste0(
str_pad(as.character(tmp[[st_col]]), 2, pad = "0"),
str_pad(as.character(tmp[[co_col]]), 3, pad = "0"),
str_pad(as.character(tmp[[tr_col]]), 6, pad = "0")
)
}
tmp %>% mutate(geoid = geoid11) %>% select(geoid, geometry)
})
df_geo <- tract_sf %>%
left_join(df, by = "geoid") %>%
filter(!is.na(pm25)) %>%
st_transform(5070) %>%                   # planar CRS (meters); good for distances
mutate(cent = st_centroid(geometry)) %>%
mutate(
x = st_coordinates(cent)[,1],
y = st_coordinates(cent)[,2]
) %>%
st_drop_geometry()
# Spatial position factor (coordinates in meters; rounding reduces accidental duplicates)
df_fit <- df_geo%>%
mutate(
pos = numFactor(round(x), round(y)),
dummy = factor(1)   # required "grouping" factor for the spatial covariance term
)
m_sp_mat <- glmmTMB(
pm25 ~ pct_white_10 + log_dens + pct_pov + ruca_agg + bc + hyads +
(1 | state_fips) + (1 | cbsa_in_state) +
mat(pos + 0 | dummy),
data = df_fit,
family = gaussian()
)
m_fe <- lm(
pm25 ~ pct_white_10 + log_dens + pct_pov + ruca_agg + bc + hyads +
factor(state_fips) + factor(cbsa_id),
data = df_model
)
summary(m_fe)
df_model <- df %>%
mutate(
# IDs
state_fips = str_pad(as.character(state_fips), 2, pad = "0"),
cbsa_id    = as.character(cbsa_id),
# nested cluster ID
cbsa_in_state = interaction(state_fips, cbsa_id, drop = TRUE),
# Urbanicity as factor (set your preferred baseline)
ruca_agg = factor(ruca_agg, levels = c("urban", "suburban", "rural")),
# Key transforms
pct_white_10 = pct_white / 10,         # +10 percentage points
log_dens     = log(dens + 1e-6)         # avoid log(0)
) %>%
# keep complete cases for variables used in models
drop_na(pm25, pct_white_10, log_dens, pct_pov, ruca_agg, bc, hyads, state_fips, cbsa_in_state, cbsa_id)
# -------------------------
# 1) Primary multilevel model
#    Random intercepts: state + CBSA-within-state
# -------------------------
m1 <- lmer(
pm25 ~ pct_white_10 + log_dens + pct_pov + ruca_agg + bc + hyads +
(1 | state_fips) + (1 | cbsa_in_state),
data = df_model,
REML = TRUE
)
summary(m1)
confint(m1, method = "Wald")  # quick CI
# Tidy fixed effects
broom.mixed::tidy(m1, effects = "fixed", conf.int = TRUE)
# Diagnostics
performance::check_model(m1)
# Interpretation helper: effect per +10 percentage points White
beta_white <- fixef(m1)["pct_white_10"]
cat("\nEstimated change in PM2.5 for +10 percentage points White:",
round(beta_white, 4), "ug/m^3\n")
# ------------------------------------------------
# 2) Sensitivity A: random slope for % White by CBSA-in-state
#    (more flexible, can be slower / may warn if near-singular)
# ------------------------------------------------
m2 <- lmer(
pm25 ~ pct_white_10 + log_dens + pct_pov + ruca_agg + bc + hyads +
(1 | state_fips) + (1 + pct_white_10 | cbsa_in_state),
data = df_model,
REML = TRUE,
control = lmerControl(optimizer = "bobyqa")
)
summary(m2)
performance::check_model(m2)
# Compare m1 vs m2 (REML=TRUE isn’t ideal for LRT; refit with REML=FALSE if you want formal LRT)
m1_ml <- update(m1, REML = FALSE)
m2_ml <- update(m2, REML = FALSE)
anova(m1_ml, m2_ml)
View(df)
View(df)
df <- read_csv("tract_cbsa.csv", show_col_types = FALSE)
# Quick checks for NA
glimpse(df)
colSums(is.na(df)) %>% sort(decreasing = TRUE) %>% head(20)
df <- df %>%
filter(!is.na(pm25), !is.na(bc))
# -------------------------
# 1) Primary multilevel model
#    Random intercepts: state + CBSA-within-state
# -------------------------
m1 <- lmer(
pm25 ~ pct_white + dens + pct_pov + ruca_agg + bc + hyads +
(1 | state_fips) + (1 | cbsa_in_state),
data = df_model,
REML = TRUE
)
summary(m1)
df_model <- df %>%
mutate(
# nested cluster ID
cbsa_in_state = interaction(state_fips, cbsa_id, drop = TRUE),
)
# -------------------------
# 1) Primary multilevel model
#    Random intercepts: state + CBSA-within-state
# -------------------------
m1 <- lmer(
pm25 ~ pct_white + dens + pct_pov + ruca_agg + bc + hyads +
(1 | state_fips) + (1 | cbsa_in_state),
data = df_model,
REML = TRUE
)
summary(m1)
# Tidy fixed effects
broom.mixed::tidy(m1, effects = "fixed", conf.int = TRUE)
# ------------------------------------------------
# 2) Sensitivity A: random slope for % White by CBSA-in-state
#    (more flexible, can be slower / may warn if near-singular)
# ------------------------------------------------
m2 <- lmer(
pm25 ~ pct + dens + pct_pov + ruca_agg + bc + hyads +
(1 | state_fips) + (1 + pct_white_10 | cbsa_in_state),
data = df_model,
REML = TRUE,
control = lmerControl(optimizer = "bobyqa")
)
# ------------------------------------------------
# 2) Sensitivity A: random slope for % White by CBSA-in-state
#    (more flexible, can be slower / may warn if near-singular)
# ------------------------------------------------
m2 <- lmer(
pm25 ~ pct_white + dens + pct_pov + ruca_agg + bc + hyads +
(1 | state_fips) + (1 + pct_white_10 | cbsa_in_state),
data = df_model,
REML = TRUE,
control = lmerControl(optimizer = "bobyqa")
)
# ------------------------------------------------
# 2) Sensitivity A: random slope for % White by CBSA-in-state
#    (more flexible, can be slower / may warn if near-singular)
# ------------------------------------------------
m2 <- lmer(
pm25 ~ pct_white + dens + pct_pov + ruca_agg + bc + hyads +
(1 | state_fips) + (1 + pct_white | cbsa_in_state),
data = df_model,
REML = TRUE,
control = lmerControl(optimizer = "bobyqa")
)
summary(m2)
# ------------------------------------------------
# 2) Sensitivity A: random slope for % White by CBSA-in-state
#    (more flexible, can be slower / may warn if near-singular)
# ------------------------------------------------
m2 <- lmer(
pm25 ~ pct_white + dens + pct_pov + ruca_agg + bc + hyads +
(1 | state_fips) + (1 + pct_white | cbsa_in_state),
data = df_model,
REML = TRUE
)
isSingular(m2)
View(df_model)
# ------------------------------------------------
# 2) Sensitivity A: random slope for % White by CBSA-in-state
#    (more flexible, can be slower / may warn if near-singular)
# ------------------------------------------------
m2 <- lmer(
pm25 ~ pct_white + log(dens) + pct_pov + ruca_agg + bc + hyads +
(1 | state_fips) + (1 + pct_white | cbsa_in_state),
data = df_model,
REML = TRUE
)
summary(m2)
View(df_fit)
